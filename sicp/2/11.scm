#lang sicp

(define (make-interval a b) (cons a b))
(define (lower-bound c) (car c))
(define (upper-bound c) (cdr c))

(define (mul-interval x y)
  (define (>= x y) (not (< x y)))
  (let ((lx (lower-bound x))
        (ux (upper-bound x))
        (ly (lower-bound y))
        (uy (upper-bound y)))
    (cond ((and (< lx 0) (< ux 0) (< ly 0) (< uy 0))
           (make-interval (* ux uy) (* lx ly)))
          ((and (< lx 0) (< ux 0) (< ly 0) (>= uy 0))
           (make-interval (* lx uy) (* lx ly)))
          ((and (< lx 0) (< ux 0) (>= ly 0) (>= uy 0))
           (make-interval (* lx uy) (* ux ly)))
          ((and (< lx 0) (>= ux 0) (< ly 0) (< uy 0))
           (make-interval (* ux ly) (* lx ly)))
          ((and (< lx 0) (>= ux 0) (< ly 0) (>= uy 0))
           (let ((p1 (* lx ly))
                 (p2 (* lx uy))
                 (p3 (* ux ly))
                 (p4 (* ux uy)))
             (make-interval (if (< p2 p3) p2 p3)
                            (if (> p1 p4) p1 p4))))
          ((and (< lx 0) (>= ux 0) (>= ly 0) (>= uy 0))
           (make-interval (* lx uy) (* ux uy)))
          ((and (>= lx 0) (>= ux 0) (< ly 0) (< uy 0))
           (make-interval (* ux ly) (* lx uy)))
          ((and (>= lx 0) (>= ux 0) (< ly 0) (>= uy 0))
           (make-interval (* ux ly) (* ux uy)))
          (else
           (make-interval (* lx ly) (* ux uy))))))
