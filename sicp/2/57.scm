#lang sicp

(define (filter pred sequence)
  (cond ((null? sequence) nil)
        ((pred (car sequence))
         (cons (car sequence) (filter pred (cdr sequence))))
        (else (filter pred (cdr sequence)))))
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))

(define (=number? exp num) (and (number? exp) (= exp num)))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (make-sum-list l)
  (let ((vars (filter (lambda (x) (not (number? x))) l))
        (nos (filter number? l)))
    (let ((sum-nos (accumulate + 0 nos)))
      (let ((final (if (= sum-nos 0) vars (cons sum-nos vars))))
        (cond ((null? final) 0)
              ((null? (cdr final)) (car final))
              (else (cons '+ final)))))))
(define (make-sum . a)
  (make-sum-list a))
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (make-sum-list (cddr s)))

(define (make-product-list l)
  (let ((vars (filter (lambda (x) (not (number? x))) l))
        (nos (filter number? l)))
    (let ((prod-nos (accumulate * 1 nos)))
      (let ((final (cond ((= prod-nos 0) '())
                         ((= prod-nos 1) vars)
                         (else (cons prod-nos vars)))))
        (cond ((null? final) 0)
              ((null? (cdr final)) (car final))
              (else (cons '* final)))))))
(define (make-product . a)
  (make-product-list a))
(define (product? x) (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (make-product-list (cddr p)))
